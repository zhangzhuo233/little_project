大数的要求：
客户端-服务器
256进制
加密传输





typename SeqList<Type>::reference

重载[]
Inc不使用realloc
LoadData加载大数
Print打印大数
>>问1:
    为什么打印时要进行int强转？
    由rand()%10生成0~9随机数，由于是int类型的,而SeqList<u_char>定义的是unsigned char类型，所以存储的将是这个十进制数对应的ASCII字符，如果不进行强制类型转换，那么打印出来的是0～9对应的字符，在linux上可能出现显示不出来的状况，所以要对其进行强转成int类型，打印出来的将是0～9
>>问2:
    为什么大数存储时，采用尾插？
    答：举个栗子，产生随机数分别为12345，在base中由低位到高位分别是12345，分别为个位十位...；
    所以呢，我们采取尾插的方式，就有这样的好处，高位进位直接往高位存储，这样后插顺序表比较高效。打印时由高位往低位打印。
    当用户输入时,还要另外处理.
>>size_t size()const
由于const BigInt &bt1导致bt1不能改变，所以size()里面的this指针要保证值为const类型
>>问3：
    为什么类中行为函数声明成静态？
    这样不需要实例化出对象，直接用类名来调动方法
>>不使用随机数时由用户输入
    构造函数实现时候不需要默认值
>>清除bt空间
>>清除前面的0
>>在加载大数时，一定要先清空res,否则最终使用头插0对齐相乘的方法，程序会崩溃.
************************************************************
后期增加负数的支持
第一位没有放数,用来存符号
加密
++
256进制的存储方案
***************************************
蒙哥马利算法
(a*b)%c = (a%c)*(b%c)%c
整数&1可以判断这个整数是不是偶数
对象初始化对象要调用拷贝构造函数，所以SeqList(const SeqList<Type> &bt),一定要写，BigInt后++和--要用
***************************************
2017-4-5
大数的次幂目前只支持非负数次幂
2017-4-6
256进制
